#!/bin/bash

VERBOSE=false
CONFIRM=true
NO_CLEANUP=false
DRY_RUN=false

function error {
	>&2 echo -e "$*"
}
function fatal {
	>&2 echo -e "$*"
	exit 1
}
function verbose {
	if $VERBOSE; then
		>&2 echo -e "$*"
	fi
}
function confirm {
    if $DRY_RUN; then
        echo -e "Dry-run. Exiting."
        exit 0
    fi
	if $CONFIRM; then
		echo -e "\nPress ENTER to continue or CTRL-C to abort"
		read -r
	fi
}

function usage {
	cat << EOE
Usage: mediautil [OPTION]... [FILE]

Operations:
  --set-audio-lang {lang}	Sets audio language of the specified file 

  --output-container {container} Specify a new output container

  --delete-audio-track {track}

  --delete-audio-tracks-except {track}

Common options:
  -v    		Verbose
  --no-cleanup 	Disables cleanup after completed action, i.e. old and new file will both remain.
  --confirm		Asks for confirmation before executing action
  --dry-run     Make no changes

EOE
    exit 1
}

function set_audio_language {
	local language audio_streams extra_params
	language=$1
	audio_streams=$(get_streams "$INPUTFILE" | grep "Audio:") || fatal "No audio streams found."
	if [ "$(echo "$audio_streams" | wc -l)" -gt 1 ]; then
		fatal "More than one audio stream found: \n$audio_streams"
	fi
	echo -e "Found audio stream:\n$audio_streams"
    echo -e "\nWill update stream language tag to: $language"

    if [[ $CONTAINER_CHANGE = true ]]; then
        extra_params="-dn -map_chapters -1"
    fi

    confirm
    echo "ffmpeg -i \"$INPUTFILE\" -map 0 -c copy -metadata:s:a:0 language=$language $extra_params $WORKING_FILE"
	
	ffmpeg -nostdin -analyzeduration 100000000 -probesize 100000000 -loglevel warning -i "$INPUTFILE" -map 0 -c copy -metadata:s:a:0 language=$language $extra_params "$WORKING_FILE" || fatal "Failed to update audio stream language"
	
	cleanup
}

function change_container {
	# '-map_chapters -1' removes any potential chapters, which may not be supported by the target container
	echo -e "Will change container to: $OUTPUT_CONTAINER"

	confirm
	echo "ffmpeg -i \"$INPUTFILE\" -map 0 -c copy -dn -map_chapters -1 \"$WORKING_FILE\""
    ffmpeg -nostdin -analyzeduration 100000000 -probesize 100000000 -loglevel warning -i "$INPUTFILE" -map 0 -c copy -dn -map_chapters -1 "$WORKING_FILE" || fatal "Failed to change container"
	
	cleanup
}

function delete_audio_tracks_except {
	local track audio_streams num_streams stream_to_match streams_to_remove
	track=$1
	# Stream #0:1(eng): Audio: aac (LC), 48000 Hz, 7.1, fltp (default)
	# Stream #0:2(eng): Audio: aac (HE-AAC), 48000 Hz, stereo, fltp
	audio_streams=$(get_streams "$INPUTFILE" | grep "Audio:") || fatal "No audio streams found."
	num_streams=$(echo "$audio_streams" | wc -l)
	echo -e "$num_streams streams found: \n$audio_streams"

	if [ "$track" -ge "$num_streams" ] || [ "$track" -lt 0 ]; then
		fatal "Invalid audio stream selected: $track. \nRemember that stream indexes start from 0"
	fi

	stream_to_match=$((track+1))
	streams_to_remove=$(echo "$audio_streams" | grep -v -E "Stream #[0-9]+:${stream_to_match}") || fatal "Failed to resolve stream to delete"
	delete_audio_streams "$streams_to_remove"
}

function delete_audio_track {
	local track audio_streams num_streams stream_to_match stream_to_remove
	track=$1
	# Stream #0:1(eng): Audio: aac (LC), 48000 Hz, 7.1, fltp (default)
	# Stream #0:2(eng): Audio: aac (HE-AAC), 48000 Hz, stereo, fltp
	audio_streams=$(get_streams "$INPUTFILE" | grep "Audio:") || fatal "No audio streams found."
	num_streams=$(echo "$audio_streams" | wc -l)
	echo -e "$num_streams streams found: \n$audio_streams"

	if [ "$track" -ge "$num_streams" ] || [ "$track" -lt 0 ]; then
		fatal "Invalid audio stream selected: $track. \nRemember that stream indexes start from 0"
	fi

	stream_to_match=$((track+1))
	stream_to_remove=$(echo "$audio_streams" | grep -E "Stream #[0-9]+:${stream_to_match}") || fatal "Failed to resolve stream to delete"
	delete_audio_streams "$stream_to_remove"
}

function delete_audio_streams {
	local streams_to_remove removal_params
	# Stream #0:1(eng): Audio: aac (LC), 48000 Hz, 7.1, fltp (default)
	# Stream #0:2(eng): Audio: aac (HE-AAC), 48000 Hz, stereo, fltp
	streams_to_remove=$1

	removal_params=$(echo "$streams_to_remove" | cut -d':' -f2 | cut -d'(' -f1 | awk '{print "-map -0:a:"$0-1}' | tr '\n' ' ')
	verbose "Removal params resolved to: $removal_params"

	echo -e "\nAbout to remove streams:\n$streams_to_remove\n"
	confirm

	echo ffmpeg -i "$INPUTFILE" -map 0 $removal_params -c copy "$WORKING_FILE"
	ffmpeg -nostdin -analyzeduration 100000000 -probesize 100000000 -loglevel warning -i "$INPUTFILE" -map 0 $removal_params -c copy "$WORKING_FILE" || fatal "ffmpeg failure"

	cleanup
}

function get_file_info {
	local retcode file file_info
	file=$1
	file_info=$(ffprobe -analyzeduration 100000000 -probesize 100000000 -hide_banner -of csv "$file" 2>&1) || fatal "Failed to resolve file info using ffprobe. Output: \n$file_info"
	retcode=$?
	verbose "ffprobe result: \n$file_info"
	echo "$file_info"
	return "$retcode"
}
function get_streams {
	get_file_info "$1" | grep "Stream #"
}
function cleanup {
	if $NO_CLEANUP; then
		echo "no-cleanup flag enabled, will not remove old file."
		echo -e "\nOriginal file: $INPUTFILE"
		echo -e "Modified file: $WORKING_FILE"
		return 0
	fi
	if [ ! -f "$WORKING_FILE" ]; then
		fatal "$WORKING_FILE does not exist. Aborting cleanup"
	fi
	rm -v "$INPUTFILE"
	mv -v "$WORKING_FILE" "$OUTPUT_FILE"
	echo
}

while [ $# -gt 1 ]; do
	case $1 in
		--set-audio-lang)
			COMMAND=$1
			NEW_AUDIO_LANGUAGE=${2:?'--set-audio-lang requires a parameter'}
			shift 1
			;;
		--output-container)
			OUTPUT_CONTAINER=${2:?'--output-container requires a parameter'}
			shift 1
			;;
		--delete-audio-track)
			COMMAND=$1
			track_sel=${2:?'parameter required'}
			shift 1
			;;
		--delete-audio-tracks-except)
			COMMAND=$1
			track_sel=${2:?'parameter required'}
			shift 1
			;;
		--no-cleanup)
			NO_CLEANUP=true
			;;
		--confirm)
			CONFIRM=true
			;;
        --no-confirm)
			CONFIRM=false
			;;
        --nono|--dry-run)
            DRY_RUN=true
            ;;
		-v|--verbose)
			VERBOSE=true
			;;
        -h|--help)
            usage
            ;;
		*) 
			fatal "Invalid argument: $1"
			;;
	esac
	shift
done

INPUTFILE=$1
[ ! -f "$INPUTFILE" ] && fatal "Input file does not exist: $INPUTFILE"
[ -z "$INPUTFILE" ] && fatal "No input file specified."
echo -e "\nInput file: $INPUTFILE"

WORKING_DIR=$(cd "$(dirname "$INPUTFILE")" && pwd)
INPUTFILE_BASENAME=$(basename "$INPUTFILE")
INPUTFILENAME_WITHOUT_EXTENSION=${INPUTFILE_BASENAME%.*}
INPUTFILE_EXTENSION=${INPUTFILE_BASENAME##*.}

if [ -z "$OUTPUT_CONTAINER" ]; then
	OUTPUT_CONTAINER=$INPUTFILE_EXTENSION

elif [[ "$INPUTFILE_EXTENSION" != "$OUTPUT_CONTAINER" ]]; then
    CONTAINER_CHANGE=true
    if [ -z "$COMMAND" ]; then
        COMMAND="--output-container"
    fi
fi

[ -z "$COMMAND" ] && usage

WORKING_FILE="$WORKING_DIR/${INPUTFILENAME_WITHOUT_EXTENSION}.new.${OUTPUT_CONTAINER}"
verbose "Working file: $WORKING_FILE"
[ -f "$WORKING_FILE" ] && fatal "Work file already exists: $WORKING_FILE"

OUTPUT_FILE="$WORKING_DIR/${INPUTFILENAME_WITHOUT_EXTENSION}.${OUTPUT_CONTAINER}"
verbose "Output file: $OUTPUT_FILE"
if [[ $CONTAINER_CHANGE != true ]] && [ -f "$OUTPUT_FILE" ]; then
	fatal "Output file already exists: $OUTPUT_FILE"
fi

case $COMMAND in
    --set-audio-lang) 					set_audio_language "$NEW_AUDIO_LANGUAGE" ;;
	--output-container)					change_container "$OUTPUT_CONTAINER";;
	--delete-audio-track)				delete_audio_track "$track_sel" ;;
	--delete-audio-tracks-except)	delete_audio_tracks_except "$track_sel" ;;
	*)
		fatal "Unknown command: $COMMAND" ;;
esac
