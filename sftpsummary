#!/usr/bin/python

import argparse
from datetime import datetime, timedelta
import re
import subprocess
import os
import sys

class LogEntry:
    DATETIME_PATTERN = re.compile(r'^\d+-\d+-\d+ \d+:\d+:\d+')
    USER_PATTERN = re.compile(r'session opened for local user ([\w\.]+) from \[')
    SESSIONID_PATTERN = re.compile(r'\[(\d+)\]')
    TYPE_PATTERN = re.compile(r'\[\d+\]: (\w+) ')
    DETAILS_PATTERN = re.compile(r'\[\d+\]: \w+ \"(.+)\"')

    def __init__(self, line):
        self.line = line

    def get_user(self) -> str:
        return self.__get_match(self.USER_PATTERN)
    def get_time(self) -> str:
        return self.__get_match(self.DATETIME_PATTERN)
    def get_session_id(self) -> str:
        return self.__get_match(self.SESSIONID_PATTERN)

    def get_type(self) -> str:
        if ": session opened " in self.line:
            return "sessionOpen"
        elif ": session closed " in self.line:
            return "sessionClose"
        else:
            return self.__get_match(self.TYPE_PATTERN)
    
    def get_details(self) -> str:
        return self.__get_match(self.DETAILS_PATTERN)

    def __get_match(self, pattern) -> str:
        matches = pattern.findall(self.line)
        if len(matches) > 0:
            return matches[0]
        return ""

class Session:
    def __init__(self, sessionId):
        self.id = sessionId
        self.user_actions = list()
        self.start = ""
        self.end = ""
        self.user = ""

    def add_user_action(self, time, actionType, details) -> None:
        self.user_actions.append(UserAction(time, actionType, details))

    def create_summary(self) -> str:
        result = f"{self.user} [{self.id}] {self.start} - {self.end}\n"
        for action in self.user_actions:
            result += action.time + "|" + action.type + "|" + action.details + "|!\n"
        return result

class UserAction:
    def __init__(self, time, aType, details):
        self.time = time
        self.type = aType
        self.details = details

class SessionsResolver:
    LOG_FILE_PATH = "/var/log/sftp.log"
    FILTERS = [": opendir ", ": closedir ", ": close "]

    def __init__(self) -> None:
        self.sessions = dict()

    def find_sessions(self, date: str) -> list[Session]:
        if not os.path.exists(self.LOG_FILE_PATH):
            print(f"Error: sftp log file does not exist: {self.LOG_FILE_PATH}", file=sys.stderr)
            return []

        with open(self.LOG_FILE_PATH, "r") as logfile:
            for line in logfile:
                if not date or line.startswith(date):
                    if any(filtr in line for filtr in self.FILTERS):
                        continue
                    self.__process_line(line)

        return list(self.sessions.values())

    def __process_line(self, line) -> None:
        entry = LogEntry(line)
        session_id = entry.get_session_id()
        if not session_id:
            print("WARNING: Failed to get sessionId from line, will skip: \n" + line, file=sys.stderr)
            return
        
        session = self.__resolve_session(session_id)

        tType = entry.get_type()
        time = entry.get_time()

        if tType == "sessionOpen":
            session.user = entry.get_user()
            session.start = time
        elif tType == "sessionClose":
            session.end = time
        elif tType == "open":
            session.add_user_action(time, tType, entry.get_details())
        
    def __resolve_session(self, session_id) -> Session:
        if session_id in self.sessions:
            return self.sessions[session_id]
        else:
            new_session = Session(session_id)
            self.sessions[session_id] = new_session
            return new_session

def parse_arguments() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description='Process SFTP log.')

    parser.add_argument("-q", '--quiet', action="store_true", help="Suppress any output to STDOUT")
    parser.add_argument("-m", '--mail', help="Sends the parsing results to the specified email address")
    
    dategroup = parser.add_mutually_exclusive_group(required = False)
    dategroup.add_argument("-d", "--date", type=lambda d: datetime.strftime(datetime.strptime(d, "%Y-%m-%d"), "%F"), help="Only parse logs from DATE")
    dategroup.add_argument("--today", action="store_const", dest="date", const=datetime.now().strftime("%F"), help="Parse logs from today")
    dategroup.add_argument("--yesterday", action="store_const", dest="date", const=(datetime.now() - timedelta(days=1)).strftime("%F"), help="Parse logs from yesterday")

    parser.set_defaults(quiet=False)
    return parser.parse_args()

def create_summary(date: str, sessions: list[Session]) -> str:
    if date:
        result = "Summary " + date
    else:
        result = "Summary"

    result += f" ({len(sessions)} sessions)\n\n"
    
    for session in sorted(sessions, key=lambda session: session.start):
        result += session.create_summary() + "\n"
    return result

def send_email(email_body: str, email_address: str, date: str) -> None:
    subject = "server1 SFTP Summary"
    if date:
        subject += " " + date

    mailProcess = subprocess.Popen(["mailx", "-s " + subject, email_address], stdin=subprocess.PIPE)
    mailProcess.communicate(email_body.encode())

#--------------------

args = parse_arguments()
sessions = SessionsResolver().find_sessions(args.date)
summary = create_summary(args.date, sessions)

if args.mail and sessions:
    send_email(summary, args.mail, args.date)

if not args.quiet:
    print(summary)
